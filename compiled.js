function t(t,e){return t instanceof Error?new Error(`${e}: ${t.message}`):"string"==typeof t?new Error(`${e}: ${t}`):null!==t&&"object"==typeof t?new Error(`${e}: ${t.toString()}`):new Error(`${e}: ${JSON.stringify(t)}`)}class e{registerCycleError(e,r){throw t(e,`Error occurred at ${r}th item in iterator`)}registerOpError(e,r,n,i){throw t(e,`Error occurred while performing ${i} on ${n} at ${r}th item in iterator`)}compile(t){return t}}class r{handler;input;ops=[];constructor(t,n=new e){this.handler=n,this.input=r.makeIterator(t)}static makeIterator(t){return Array.isArray(t)?t[Symbol.iterator]():t}map(t){return this.ops.push({type:"map",op:t}),this}filter(t){return this.ops.push({type:"filter",op:t}),this}forEach(t){return this.ops.push({type:"foreach",op:t}),this}inspect(t=t=>console.log(t)){return this.ops.push({type:"foreach",op:t}),this}filterMap(t){return this.ops.push({type:"filterMap",op:t}),this}take(t){const e=this.read();return new r(function*(){for(let r=0;r<t;r++){const t=e.next();if(t.done)break;yield t.value}}(),this.handler)}skip(t){const e=this.read();return new r(function*(){let r=0;for(;r<t;){if(e.next().done)break;r++}yield*e}(),this.handler)}stepBy(t){const e=this.read();return new r(function*(){let r=0;for(const n of e)r%t==0&&(yield n),r++}(),this.handler)}chain(t){const e=this.read();return new r(function*(){yield*e,yield*t}(),this.handler)}intersperse(t){const e=this.read();return new r(function*(){let r=null;for(;;){const n=r||e.next();if(n.done)break;if(yield n.value,r=e.next(),r.done)break;const i="function"==typeof t?t(n.value):t;yield i}}(),this.handler)}zip(t){const e=this.read(),n=r.makeIterator(t);return new r(function*(){for(const t of e){const e=n.next();if(e.done)break;yield[t,e.value]}}(),this.handler)}enumerate(){const t=this.read();return new r(function*(){let e=0;for(const r of t)yield[e,r],e++}(),this.handler)}flatMap(t){const e=this.read();return new r(function*(){for(const r of e){const e=t(r);for(const t of e)yield t}}(),this.handler)}fuse(){const t=this.read();return new r(function*(){for(const e of t){if(null==e)break;yield e}}(),this.handler)}count(){const t=[...this.read()].length;return this.handler.compile(t)}nth(t){let e=0;for(const r of this.read()){if(e===t)return this.handler.compile(r);e++}return this.handler.compile(null)}reduce(t,e){let r=e,n=0;for(const e of this.read()){try{r=t(r,e)}catch(t){this.handler.registerOpError(t,n,e,"reduce")}n++}return this.handler.compile(r)}reduceRight(t,e){const r=[...this.read()];let n=e;for(let e=r.length-1;e>=0;e--){const i=r[e];try{n=t(n,i)}catch(t){this.handler.registerOpError(t,e,i,"reduceRight")}}return this.handler.compile(n)}flat(t){const e=[...this.read()].flat(t);return this.handler.compile(e)}any(t){for(const e of this.read())if(t(e))return this.handler.compile(!0);return this.handler.compile(!1)}all(t){for(const e of this.read())if(!t(e))return this.handler.compile(!1);return this.handler.compile(!0)}find(t){for(const e of this.read())if(t(e))return this.handler.compile(e);return this.handler.compile(null)}findIndex(t){let e=0;for(const r of this.read()){if(t(r))return this.handler.compile(e);e++}return-1}findLast(t){const e=[...this.read()];for(let r=e.length-1;r>=0;r--)if(t(e[r]))return e[r];return null}findLastIndex(t){const e=[...this.read()];for(let r=e.length-1;r>=0;r--)if(t(e[r]))return this.handler.compile(r);return this.handler.compile(-1)}includes(t){for(const e of this.read())if(e===t)return this.handler.compile(!0);return this.handler.compile(!1)}partition(t){const e=[],r=[];for(const n of this.read())t(n)?e.push(n):r.push(n);const n=[e,r];return this.handler.compile(n)}collect(){const t=[...this.read()];return this.handler.compile(t)}*read(){let t,e=0;for(;;)try{const r=this.input.next();if(r.done)break;if(t=this.applyTransformations(r.value,e),t.filtered)continue;yield t.value,e++}catch(t){this.handler.registerCycleError(t,e)}}applyTransformations(t,e){let r;for(const n of this.ops)try{switch(n.type){case"filter":if(!1===n.op(t))return{filtered:!0};break;case"map":t=n.op(t);break;case"foreach":n.op(t);break;case"filterMap":if(r=n.op(t),null===r||!1===r||void 0===r)return{filtered:!0};t=r}}catch(r){this.handler.registerOpError(r,e,t,n.type)}return{value:t,filtered:!1}}}class n{input;ops=[];constructor(t){this.input=n.makeIterator(t)}static makeIterator(t){if("promise"in t){const e=t.promise;async function*r(){for(;;){const t=await e();if(null==t)break;yield t}}return r()}if(Array.isArray(t)){const n=structuredClone(t);async function*i(){for(const t of n)yield t}return i()}return t}map(t){return this.ops.push({type:"map",op:t}),this}filter(t){return this.ops.push({type:"filter",op:t}),this}forEach(t){return this.ops.push({type:"foreach",op:t}),this}inspect(t=t=>console.log(t)){return this.ops.push({type:"foreach",op:t}),this}filterMap(t){return this.ops.push({type:"filterMap",op:t}),this}take(t){const e=this.read();return new n(async function*(){for(let r=0;r<t;r++){const t=await e.next();if(t.done)break;yield t.value}}())}skip(t){const e=this.read();return new n(async function*(){for(let r=0;r<t;r++){if((await e.next()).done)return}yield*e}())}stepBy(t){const e=this.read();return new n(async function*(){let r=0;for await(const n of e)r%t==0&&(yield n),r++}())}chain(t){const e=this.read(),r=n.makeIterator(t);return new n(async function*(){yield*e,yield*r}())}intersperse(t){const e=this.input;return new n(async function*(){let r=null;for(;;){const n=r||await e.next();if(n.done)break;if(yield n.value,r=await e.next(),r.done)break;const i="function"==typeof t?await t(n.value):t;yield i}}())}zip(t){const e=this.read(),r=n.makeIterator(t);return new n(async function*(){for await(const t of e){const e=await r.next();if(e.done)break;yield[t,e.value]}}())}enumerate(){const t=this.read();return new n(async function*(){let e=0;for await(const r of t)yield[e,r],e++}())}flatMap(t){const e=this.read();return new n(async function*(){for await(const r of e){const e=await t(r);for(const t of e)yield t}}())}fuse(){const t=this.read();return new n(async function*(){for await(const e of t){if(null==e)break;yield e}}())}async count(){let t=0;for await(const e of this.input)t++;return t}async nth(t){let e=0;for await(const r of this.read()){if(e==t)return r;e++}return null}async reduce(t,e){let r=e;for await(const e of this.read())r=await t(r,e);return r}async reduceRight(t,e){const r=await this.collect();let n=e;for(let e=r.length-1;e>=0;e--){const i=r[e];n=await t(n,i)}return n}async flat(t){return(await this.collect()).flat(t)}async any(t){for await(const e of this.read())if(await t(e))return!0;return!1}async all(t){for await(const e of this.read())if(!await t(e))return!1;return!0}async find(t){for await(const e of this.read())if(await t(e))return e;return null}async findIndex(t){let e=0;for await(const r of this.read()){if(await t(r))return e;e++}return-1}async findLast(t){const e=await this.collect();for(let r=e.length-1;r>=0;r--)if(await t(e[r]))return e[r];return null}async findLastIndex(t){const e=await this.collect();for(let r=e.length-1;r>=0;r--)if(await t(e[r]))return r;return-1}async includes(t){for await(const e of this.read())if(e===t)return!0;return!1}async partition(t){const e=[],r=[];for await(const n of this.read())await t(n)?e.push(n):r.push(n);return[e,r]}async collect(){const t=[];for await(const e of this.read())t.push(e);return t}async*read(){for await(const t of this.input){const e=await this.applyTransformations(t);e.filtered||(yield e.value)}}async applyTransformations(t){let e;for(const r of this.ops)switch(r.type){case"filter":if(!1===await r.op(t))return{filtered:!0};break;case"map":t=await r.op(t);break;case"foreach":await r.op(t);break;case"filterMap":if(e=await r.op(t),null===e||!1===e||void 0===e)return{filtered:!0};t=e}return{value:t,filtered:!1}}}export{r as ArrayStream,n as AsyncArrayStream};
//# sourceMappingURL=index.js.map
