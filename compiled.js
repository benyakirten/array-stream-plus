class t{ops;input;constructor(e,r=[]){this.ops=r,this.input=t.makeIterator(e)}static makeIterator(t){return Array.isArray(t)?t[Symbol.iterator]():t}map(t){return this.ops.push({type:"map",op:t}),this}filter(t){return this.ops.push({type:"filter",op:t}),this}forEach(t){return this.ops.push({type:"foreach",op:t}),this}inspect(t=t=>console.log(t)){return this.ops.push({type:"foreach",op:t}),this}filterMap(t){return this.ops.push({type:"filterMap",op:t}),this}take(e){const r=this.read();return new t(function*(){for(let t=0;t<e;t++){const t=r.next();if(t.done)break;yield t.value}}(),[])}skip(e){const r=this.read();return new t(function*(){let t=0;for(;t<e;){if(r.next().done)break;t++}yield*r}(),[])}stepBy(e){const r=this.read();return new t(function*(){let t=0;for(const n of r)t%e==0&&(yield n),t++}(),[])}chain(e){const r=this.read();return new t(function*(){yield*r,yield*e}(),[])}intersperse(e){const r=this.read();return new t(function*(){let t=null;for(;;){const n=t||r.next();if(n.done)break;if(yield n.value,t=r.next(),t.done)break;const o="function"==typeof e?e():e;yield o}}(),[])}zip(e){const r=this.read(),n=t.makeIterator(e);return new t(function*(){for(const t of r){const e=n.next();if(e.done)break;yield[t,e.value]}}(),[])}enumerate(){const e=this.read();return new t(function*(){let t=0;for(const r of e)yield[t,r],t++}(),[])}flatMap(e){const r=this.read();return new t(function*(){for(const t of r){const r=e(t);for(const t of r)yield t}}(),[])}fuse(){const e=this.read();return new t(function*(){for(const t of e){if(null==t)break;yield t}}(),[])}count(){return this.collect().length}nth(t){let e=0;for(const r of this.read()){if(e===t)return r;e++}return null}reduce(t,e){let r=e;for(const e of this.read())r=t(r,e);return r}reduceRight(t,e){const r=this.collect();let n=e;for(let e=r.length-1;e>=0;e--){n=t(n,r[e])}return n}flat(t){return this.collect().flat(t)}any(t){for(const e of this.read())if(t(e))return!0;return!1}all(t){for(const e of this.read())if(!t(e))return!1;return!0}find(t){for(const e of this.read())if(t(e))return e;return null}findIndex(t){let e=0;for(const r of this.read()){if(t(r))return e;e++}return-1}findLast(t){const e=this.collect();for(let r=e.length-1;r>=0;r--)if(t(e[r]))return e[r];return null}findLastIndex(t){const e=this.collect();for(let r=e.length-1;r>=0;r--)if(t(e[r]))return r;return-1}includes(t){for(const e of this.read())if(e===t)return!0;return!1}partition(t){const e=[],r=[];for(const n of this.read())t(n)?e.push(n):r.push(n);return[e,r]}collect(){return[...this.read()]}*read(){for(const t of this.input){const e=this.applyTransformations(t);e.filtered||(yield e.value)}}applyTransformations(t){let e;for(const r of this.ops)switch(r.type){case"filter":if(!1===r.op(t))return{filtered:!0};break;case"map":t=r.op(t);break;case"foreach":r.op(t);break;case"filterMap":if(e=r.op(t),null===e||!1===e||void 0===e)return{filtered:!0};t=e}return{value:t,filtered:!1}}}class e{ops;input;constructor(t,r=[]){this.ops=r,this.input=e.makeIterator(t)}static makeIterator(t){if("promise"in t){const e=t.promise;async function*r(){for(;;){const t=await e();if(null==t)break;yield t}}return r()}if(Array.isArray(t)){const n=structuredClone(t);async function*o(){for(const t of n)yield t}return o()}return t}map(t){return this.ops.push({type:"map",op:t}),this}filter(t){return this.ops.push({type:"filter",op:t}),this}forEach(t){return this.ops.push({type:"foreach",op:t}),this}inspect(t=t=>console.log(t)){return this.ops.push({type:"foreach",op:t}),this}filterMap(t){return this.ops.push({type:"filterMap",op:t}),this}take(t){const r=this.read();return new e(async function*(){for(let e=0;e<t;e++){const t=await r.next();if(t.done)break;yield t.value}}(),[])}skip(t){const r=this.read();return new e(async function*(){for(let e=0;e<t;e++){if((await r.next()).done)return}yield*r}(),[])}stepBy(t){const r=this.read();return new e(async function*(){let e=0;for await(const n of r)e%t==0&&(yield n),e++}(),[])}chain(t){const r=this.read(),n=e.makeIterator(t);return new e(async function*(){yield*r,yield*n}(),[])}intersperse(t){const r=this.input;return new e(async function*(){let e=null;for(;;){const n=e||await r.next();if(n.done)break;if(yield n.value,e=await r.next(),e.done)break;const o="function"==typeof t?await t():t;yield o}}(),[])}zip(t){const r=this.read(),n=e.makeIterator(t);return new e(async function*(){for await(const t of r){const e=await n.next();if(e.done)break;yield[t,e.value]}}(),[])}enumerate(){const t=this.read();return new e(async function*(){let e=0;for await(const r of t)yield[e,r],e++}(),[])}flatMap(t){const r=this.read();return new e(async function*(){for await(const e of r){const r=await t(e);for(const t of r)yield t}}(),[])}fuse(){const t=this.read();return new e(async function*(){for await(const e of t){if(null==e)break;yield e}}(),[])}async count(){let t=0;for await(const e of this.input)t++;return t}async nth(t){let e=0;for await(const r of this.read()){if(e==t)return r;e++}return null}async reduce(t,e){let r=e;for await(const e of this.read())r=await t(r,e);return r}async reduceRight(t,e){const r=await this.collect();let n=e;for(let e=r.length-1;e>=0;e--){const o=r[e];n=await t(n,o)}return n}async flat(t){return(await this.collect()).flat(t)}async any(t){for await(const e of this.read())if(await t(e))return!0;return!1}async all(t){for await(const e of this.read())if(!await t(e))return!1;return!0}async find(t){for await(const e of this.read())if(await t(e))return e;return null}async findIndex(t){let e=0;for await(const r of this.read()){if(await t(r))return e;e++}return-1}async findLast(t){const e=await this.collect();for(let r=e.length-1;r>=0;r--)if(await t(e[r]))return e[r];return null}async findLastIndex(t){const e=await this.collect();for(let r=e.length-1;r>=0;r--)if(await t(e[r]))return r;return-1}async includes(t){for await(const e of this.read())if(e===t)return!0;return!1}async partition(t){const e=[],r=[];for await(const n of this.read())await t(n)?e.push(n):r.push(n);return[e,r]}async collect(){const t=[];for await(const e of this.read())t.push(e);return t}async*read(){for await(const t of this.input){const e=await this.applyTransformations(t);e.filtered||(yield e.value)}}async applyTransformations(t){let e;for(const r of this.ops)switch(r.type){case"filter":if(!1===await r.op(t))return{filtered:!0};break;case"map":t=await r.op(t);break;case"foreach":await r.op(t);break;case"filterMap":if(e=await r.op(t),null===e||!1===e||void 0===e)return{filtered:!0};t=e}return{value:t,filtered:!1}}}export{t as ArrayStream,e as AsyncArrayStream};
//# sourceMappingURL=index.js.map
